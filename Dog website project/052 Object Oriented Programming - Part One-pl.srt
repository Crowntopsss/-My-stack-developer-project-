1
00:00:05,380 --> 00:00:08,710
Witam wszystkich na tym wykładzie poświęconym programowaniu obiektowemu.

2
00:00:09,810 --> 00:00:15,420
Programowanie obiektowe lub opii pozwala programistom tworzyć własne obiekty, które mają metody

3
00:00:15,510 --> 00:00:16,710
i atrybuty.

4
00:00:16,740 --> 00:00:22,860
Przypomnijmy, że po znalezieniu słownika listy napisów lub dowolnego innego obiektu wbudowanego w pythona faktycznie mamy

5
00:00:22,860 --> 00:00:27,510
zdolność, którą nazywa się metodami od nich, używając tej nazwy składni nazwy metody.

6
00:00:27,510 --> 00:00:33,880
Na przykład, jeśli zdefiniujesz łańcuch, do którego możesz wywołać górny wyłącz tego łańcucha, aby uczynić

7
00:00:33,930 --> 00:00:41,390
go z listy, którą możesz nazwać długopisem, aby dodać coś do tej listy, te metody są funkcjami, które

8
00:00:41,390 --> 00:00:47,770
wykorzystują informacje o obiekcie, jak również jako sam obiekt do zwracania wyników lub do justowania

9
00:00:47,780 --> 00:00:49,930
ich w celu zmiany bieżącego obiektu.

10
00:00:50,000 --> 00:00:54,890
Na przykład, tak jak właśnie powiedziałem, to dołączanie czegoś do listy lub

11
00:00:54,890 --> 00:01:01,540
liczenie wystąpień elementu w krotce O. P. pozwala użytkownikom tworzyć własne obiekty.

12
00:01:01,540 --> 00:01:06,070
Ogólny format często jest dość mylący, gdy po raz pierwszy go spotkasz, a jego przydatność na

13
00:01:06,070 --> 00:01:07,950
początku może nie być całkowicie jasna.

14
00:01:07,960 --> 00:01:13,480
Ogólnie rzecz biorąc, opii pozwala nam tworzyć powtarzalny i zorganizowany kod i naprawdę zaczynamy nurkować

15
00:01:13,480 --> 00:01:14,230
w butelce.

16
00:01:14,230 --> 00:01:18,920
Będziemy używać go całkiem sporo, więc ważne jest, aby mieć solidne podstawy w tej chwili.

17
00:01:20,330 --> 00:01:24,260
Tak więc znowu dla znacznie większych skryptów kodu Pythona, takich jak te, które

18
00:01:24,590 --> 00:01:29,750
zamierzamy tworzyć same funkcje kolbowe, nie wystarczy, aby organizacja i powtarzalność często powtarzające się zadania i obiekty

19
00:01:29,750 --> 00:01:34,620
powinny być zdefiniowane jako O. P. do tworzenia kodu, który jest bardziej użyteczny.

20
00:01:34,820 --> 00:01:37,000
Sprawdźmy więc składnię.

21
00:01:37,940 --> 00:01:41,770
Masz tutaj podstawową składnię programowania obiektowego.

22
00:01:41,780 --> 00:01:46,660
Przeanalizujmy niektóre z tych słów kluczowych, zanim przejdziemy do edytora tekstów, aby zapoznać się z kilkoma przykładami.

23
00:01:47,890 --> 00:01:52,750
Zaczynamy więc od klasy słów kluczowych, a następnie decydujemy o nazwie klasy i ogłoszeniu.

24
00:01:52,780 --> 00:01:58,440
Teraz już nie podążam za tą wężową otoczką wszystkiego, co małe i podkreślam zamiast

25
00:01:58,450 --> 00:02:00,320
klas, a konwencja to wielbłąda.

26
00:02:00,340 --> 00:02:05,550
Zasadniczo mamy litery pisane wielkimi literami lub pisane wielką literą, a następnie każde nowe słowo ma literę

27
00:02:05,560 --> 00:02:10,870
wielką literą, więc mówimy o nazwie klasy w ten sposób później na twoim kodzie możesz łatwo odróżnić

28
00:02:10,960 --> 00:02:12,120
funkcję od klasy.

29
00:02:12,130 --> 00:02:17,920
Kiedy zdefiniujemy naszą klasę, mamy tę metodę init, która pozwoli nam zainicjować klasę

30
00:02:17,920 --> 00:02:23,860
i zwróć uwagę na to, jak ma kilka słów kluczowych, takich jak self,

31
00:02:23,890 --> 00:02:31,610
a potem Parama i program, mówiąc w zasadzie, co to znaczy, kiedy Utwórz instancję klasy, którą masz

32
00:02:31,610 --> 00:02:34,100
możliwość tworzenia atrybutów dla samej klasy.

33
00:02:34,100 --> 00:02:41,130
Tak więc wózek, który faktycznie przechodzisz do klasy, zostaje zatopiony w instancji samej klasy i

34
00:02:41,360 --> 00:02:45,760
faktycznie używa tego słowa kluczowego, które jest tutaj pokazane.

35
00:02:45,770 --> 00:02:50,240
Zasadniczo przejdziemy do Paramy, a potem zostanie przypisana do tego własna

36
00:02:50,300 --> 00:02:56,040
właściwość Parama, a to będzie miało więcej sensu, ponieważ faktycznie kodujemy przykłady w edytorze tekstu.

37
00:02:57,320 --> 00:03:00,830
Inną często spotykaną rzeczą wewnątrz klasy jest wywołanie metody.

38
00:03:00,890 --> 00:03:03,240
I zauważ, że to wygląda jak funkcja.

39
00:03:03,260 --> 00:03:05,300
Po prostu jest wewnątrz klasy.

40
00:03:05,300 --> 00:03:10,360
I znowu używa tego słowa kluczowego sulpha, więc używając tego samego słowa kluczowego.

41
00:03:10,360 --> 00:03:16,370
Zasadniczo ma to na celu skłonienie klasy do wykonania jakiegoś działania z informacjami o sobie i może

42
00:03:17,420 --> 00:03:18,950
niektórymi z jego parametrów.

43
00:03:18,950 --> 00:03:23,500
Tak więc w tym przypadku po prostu prosi się o wydrukowanie jednego z jego atrybutów lub parametrów.

44
00:03:24,450 --> 00:03:28,710
OK, więc przeszliśmy przez podstawową składnię, ale nie będzie to miało większego sensu, dopóki nie zaczniemy

45
00:03:28,710 --> 00:03:30,630
zabrudzać sobie rąk i zaczniemy je kodować.

46
00:03:30,720 --> 00:03:31,340
Więc zbadajmy.

47
00:03:31,350 --> 00:03:34,970
Programowanie obiektowe z większą ilością szczegółów za pomocą kodu.

48
00:03:35,110 --> 00:03:39,280
Laurie Chcę rozpocząć tę lekcję, pamiętając o podstawowych obiektach Pythona.

49
00:03:39,420 --> 00:03:46,650
Na przykład mógłbym mieć listę jeden dwa 3, a następnie mógłbym powiedzieć moją listę i dopisać coś

50
00:03:46,650 --> 00:03:47,420
do listy.

51
00:03:47,440 --> 00:03:54,990
Po drugie wywołaj tę metodę poza tym obiektem listy, a właściwie wszystko w Pythonie jest obiektem, który możesz

52
00:03:55,080 --> 00:03:58,560
przetestować lub sprawdzić za pomocą słowa kluczowego type.

53
00:03:58,800 --> 00:04:04,530
Mogę więc powiedzieć Typ mojej listy, a następnie możemy wydrukować wynik tego, aby rzeczywiście

54
00:04:05,310 --> 00:04:07,290
zobaczyć, jaki typ obiektu jest.

55
00:04:07,290 --> 00:04:15,750
Więc kiedy to uruchomię, otrzymam jego listę klas, a potem może wprowadzę tam pewną liczbę.

56
00:04:15,960 --> 00:04:19,260
Więc jaki typ ma 12 lat, kiedy to uruchomię.

57
00:04:19,290 --> 00:04:25,030
Mówi, że to klasa I. ZA. lub klasa Integer i prawie wszystkie twoje różne

58
00:04:25,030 --> 00:04:26,810
obiekty będą miały rodzaj skojarzony z nimi.

59
00:04:26,860 --> 00:04:28,950
Zróbmy więc dwadzieścia trzy punkt pięć.

60
00:04:29,230 --> 00:04:30,160
Zapisz to.

61
00:04:30,460 --> 00:04:30,890
Uruchom.

62
00:04:30,940 --> 00:04:32,660
A to jest klasa float.

63
00:04:32,740 --> 00:04:38,140
Główną ideą jest to, że nie będziemy w stanie stworzyć własnej klasy, więc powiem, że klasa, a następnie niezależnie

64
00:04:38,140 --> 00:04:42,620
od klasy, którą stworzyliśmy, a następnie nasze klasy będą miały własne metody, które możemy zdefiniować.

65
00:04:43,000 --> 00:04:44,820
Wypróbujmy to.

66
00:04:45,220 --> 00:04:51,260
Zaczniemy od użycia słowa kluczowego class, a następnie wybierz nazwę klasy, która jest wielkimi literami.

67
00:04:51,260 --> 00:04:58,460
W naszym przypadku po prostu nazwiemy ten przykład, a następnie możemy mieć dwukropek lub otworzyć i zamknąć nawiasy.

68
00:04:58,460 --> 00:05:00,870
Albo będzie działać dobrze na otwartej i zamkniętej.

69
00:05:00,870 --> 00:05:06,290
Książę jest teraz, ponieważ później będziemy ich potrzebować do dziedziczenia z innych klas.

70
00:05:06,500 --> 00:05:10,060
Więc powiemy dwukropek próbny klasy, a następnie przekazujemy.

71
00:05:10,070 --> 00:05:11,810
Zasadniczo ta klasa jest całkowicie pusta.

72
00:05:11,810 --> 00:05:15,830
Nic nie robi, a potem tworzę instancję klasy.

73
00:05:15,830 --> 00:05:20,310
Jest to bardzo podobne do tego, kiedy robimy coś takiego, jak tworzenie instancji obiektu.

74
00:05:20,530 --> 00:05:24,060
Więc powiem, że x jest równy próbce.

75
00:05:24,350 --> 00:05:26,250
Otwieranie i zamykanie książąt.

76
00:05:26,320 --> 00:05:29,030
Przejdźmy dalej i sprawdźmy typ tego obiektu.

77
00:05:29,030 --> 00:05:31,240
Powiem więc, co to jest typ x.

78
00:05:32,130 --> 00:05:36,330
A kiedy to uruchomię, to mówi: główna próbka klasy.

79
00:05:36,630 --> 00:05:41,400
I na końcu sekcji kurs będzie mówił o tej głównej zmiennej bardziej, że możesz uzyskać

80
00:05:41,400 --> 00:05:45,570
pomysł, że w tym przypadku udało nam się już stworzyć własny typ ogic.

81
00:05:45,570 --> 00:05:48,960
To naprawdę prosty obiekt nazywany obiektem próbki.

82
00:05:48,960 --> 00:05:54,570
OK, rozwińmy ten pomysł, zaczynając rozumieć atrybuty obiektów, aby to zrobić.

83
00:05:54,600 --> 00:06:02,240
Zamierzam stworzyć całkowicie nową klasę, do której stworzymy obiekt klasy lub psa.

84
00:06:02,240 --> 00:06:08,950
Powiedzmy, że to pies klasy, a potem użyję specjalnej metody, a te specjalne metody są często

85
00:06:09,080 --> 00:06:13,120
nazywane metodami Dunder, ponieważ mają podwójny zestaw podkreśleń otaczających je.

86
00:06:13,330 --> 00:06:21,730
Więc powiem że podkreślenie podkreślenia I i T podkreślenia podkreślenia, a następnie zamierzam przekazać

87
00:06:21,730 --> 00:06:27,390
parametr własny, a następnie zamierzam przekazać kolejny argument za Breede.

88
00:06:27,580 --> 00:06:29,500
Więc mam rasę psa.

89
00:06:29,560 --> 00:06:38,600
Powiedzą dwukropek, a powiemy, że rasa samouk jest równa rasie.

90
00:06:38,670 --> 00:06:40,900
Więc podzielmy to, co się tutaj dzieje.

91
00:06:41,040 --> 00:06:47,370
Mamy tę metodę i jest ona automatycznie wywoływana zaraz po utworzeniu instancji tego obiektu.

92
00:06:47,580 --> 00:06:53,870
A następnie każdy atrybut w definicji klasy rozpoczyna się w odniesieniu do rzeczywistego obiektu instancji.

93
00:06:53,880 --> 00:06:59,040
Tak więc zgodnie z konwencją to właśnie słowo kluczowe samo mówi, że mówimy,

94
00:06:59,040 --> 00:07:06,210
że ta konkretna instancja obiektu, na przykład gdy mówimy coś takiego jak x, jest równa psowi, a ta

95
00:07:06,210 --> 00:07:14,660
sprawa będzie musiała dostarczyć rasę, taką jak laboratorium lub powiedzenie OK X ta instancja psa tej rasy będzie tą, która została

96
00:07:14,660 --> 00:07:15,980
wtedy przekazana.

97
00:07:15,980 --> 00:07:17,900
W tym przypadku jest to laboratorium.

98
00:07:17,900 --> 00:07:19,570
Zobaczmy więc, co się tutaj stanie.

99
00:07:20,850 --> 00:07:30,520
W rzeczywistości chodźmy dalej, a następnie wydrukujmy typ x, więc uruchomimy to i wrócimy.

100
00:07:30,550 --> 00:07:32,470
Mamy główny typ psa.

101
00:07:32,630 --> 00:07:40,690
Co ciekawe jest teraz poza moim doctype'em, będę mógł nazwać go rasą jako atrybut.

102
00:07:40,730 --> 00:07:46,220
Więc kiedy to przeczytam, mówi, że typ jest ciągiem, który ma sens, ale

103
00:07:46,220 --> 00:07:54,200
jeśli po prostu poprosię o Breit, ponieważ lab jest ciągiem, który będzie informował o rasie x zmiennej instancji psa

104
00:07:54,200 --> 00:07:58,190
jest laboratorium, ponieważ to właśnie ty znajdź tutaj jako rasy.

105
00:07:58,460 --> 00:08:04,040
Więc wszystko, co tu robisz, to wtedy, gdy wywołujesz psa instancją psa, automatycznie wywołujesz tę

106
00:08:04,040 --> 00:08:07,610
metodę inicjalizacji, a następnie masz jakiekolwiek argumenty lub parametry.

107
00:08:07,640 --> 00:08:12,650
Zasadniczo wszelkie atrybuty, które chcesz dla obiektu i systemu dla siebie.

108
00:08:12,800 --> 00:08:14,800
I w tym przypadku kończy się to X. Więc X tutaj, to jest połączenie.

109
00:08:14,870 --> 00:08:18,130
Teraz mówimy, że kropki nazwa atrybutu jest równa temu, który atrybut został wtedy przekazany.

110
00:08:18,140 --> 00:08:23,150
W tym przypadku jest to laboratorium.

111
00:08:23,180 --> 00:08:24,640
Tak więc zasadniczo mówi się, że Breede jest równy lab.

112
00:08:24,860 --> 00:08:29,250
Więc są w tym laboratorium Negatu znowu.

113
00:08:29,330 --> 00:08:31,170
Często dla początkujących mylące jest

114
00:08:31,370 --> 00:08:37,200
to, że używamy tu Breede trzy razy rasy i samouka, aby było to naprawdę jasne.

115
00:08:37,400 --> 00:08:40,340
Chcę ci pokazać, że możesz to również powiedzieć.

116
00:08:40,560 --> 00:08:43,330
Mógłbym powiedzieć, że wprowadzam rasową rasę wejściową, a następnie mówię o tym i kładę Breede'a tak,

117
00:08:43,790 --> 00:08:45,140
abyśmy zrobili to jak husky czy coś takiego.

118
00:08:47,990 --> 00:08:55,970
Mówiąc to, kiedy tworzysz instancję klasy lalek, tak jak robię tutaj

119
00:08:58,240 --> 00:09:03,310
linię 6, automatycznie wywołasz tę metodę init.

120
00:09:03,310 --> 00:09:06,150
A potem użyjesz słowa kluczowego self, aby przypisać atrybuty.

121
00:09:06,370 --> 00:09:10,350
Powiemy więc, że to samo w istocie staje się

122
00:09:10,360 --> 00:09:15,370
X, więc X, że rasa będzie czymkolwiek, co przekazałeś jako rasę wejściową.

123
00:09:15,370 --> 00:09:17,220
Więc bierzesz rasę wejściową i przypisujesz ją samoukiem, który kończy się na Huskey.

124
00:09:17,290 --> 00:09:22,620
Więc kiedy mówisz o rasie księcia X i biegniesz, dostajesz Huskeya.

125
00:09:22,630 --> 00:09:27,650
Zauważ, jak to działa.

126
00:09:27,850 --> 00:09:29,010
Ponownie po prostu

127
00:09:29,020 --> 00:09:33,670
przekazujesz argument wejściowy dla atrybutu, a następnie przypisujesz argument wejściowy do nazwy atrybutu.

128
00:09:34,060 --> 00:09:35,620
Teraz zgodnie z konwencją zazwyczaj zarówno

129
00:09:35,620 --> 00:09:40,510
argument, jak i atrybut mają tę samą nazwę, dlatego właśnie widzisz coś takiego jak rasa, a następnie rozmnażają się.

130
00:09:40,510 --> 00:09:44,520
Ale chciałem ci pokazać ten aspekt, żebyś się nie pomylił mówiąc, że trzy razy się rozmnażasz.

131
00:09:44,590 --> 00:09:48,630
Tak więc prawie wszystkie nazwy atrybutów będą je widzieć trzy razy

132
00:09:48,730 --> 00:09:53,440
jeden dla argumentu dla przypisania, a następnie dla faktycznego wywołania atrybutu kropki.

133
00:09:53,440 --> 00:09:57,520
OK, spróbujmy dodać inny atrybut.

134
00:09:57,530 --> 00:10:00,440
Więc pies powinien mieć imiona, więc powiem rasę i

135
00:10:00,500 --> 00:10:07,490
imię, a potem powiemy, że ten przypadek psa samouka, który ma na imię, będzie imieniem, które zostanie przekazane, więc uratujemy to i dostarczymy.

136
00:10:07,520 --> 00:10:14,480
Teraz musimy to zmienić z powrotem na rasę.

137
00:10:14,480 --> 00:10:16,760
W rzeczywistości nie musimy mówić, że rasa jest równa

138
00:10:17,120 --> 00:10:22,010
i mówi, że może po prostu powiedzieć, że jest po prostu chuda, a wtedy imię tego psa będzie oznaczało Sammy.

139
00:10:22,010 --> 00:10:27,250
Teraz zmienmy teraz tę zmienną na "Sam", więc mogę prosić o atrybuty Sama. Mogę powiedzieć,

140
00:10:27,260 --> 00:10:33,890
co to jest Sam, która jest rasą, czy Prince, jak nazywa się Sam Pies i to jest tutaj.

141
00:10:33,890 --> 00:10:42,820
Ponieważ są to atrybuty, nie mam księży otwartych i bliskich.

142
00:10:42,830 --> 00:10:46,380
Będą to metody, o których później opowiadamy, po to, aby książęta prowadzili

143
00:10:46,490 --> 00:10:48,420
to, a teraz widzę Huskeya i Samie.

144
00:10:51,350 --> 00:10:56,760
Mam więc tego przykład psa, którego rasa jest husky, a Sammy będzie imieniem tego psa.

145
00:10:56,980 --> 00:11:03,130
Więc to są podstawy atrybutów.

146
00:11:03,430 --> 00:11:05,680
Teraz istnieją również tak zwane atrybuty obiektów klas.

147
00:11:05,680 --> 00:11:09,290
Możemy więc powiedzieć atrybuty obiektów klasowych.

148
00:11:09,460 --> 00:11:14,210
A to są atrybuty zdefiniowane poza wszelkimi metodami klasy.

149
00:11:14,480 --> 00:11:18,530
Więc to będzie poza tymi metodami.

150
00:11:18,530 --> 00:11:21,180
I zgodnie z konwencją są one pierwszą rzeczą, która

151
00:11:21,230 --> 00:11:26,210
pojawia się w niej, celem atrybutu obiektów klasowych są rzeczy, które będą prawdziwe niezależnie od instancji psa.

152
00:11:26,240 --> 00:11:31,490
Na przykład można powiedzieć, że gatunek psa jest ssakiem.

153
00:11:31,490 --> 00:11:38,440
Teraz technicznie biologicznie to nieprawda.

154
00:11:38,440 --> 00:11:40,440
W rzeczywistości jest to inny termin

155
00:11:40,450 --> 00:11:44,440
nazywany klasą dla ssaka, ale nie chcę się mylić z tym słowem kluczowym.

156
00:11:44,500 --> 00:11:45,280
Powiedz tylko gatunki.

157
00:11:45,460 --> 00:11:46,830
Więc jeśli masz znajomą biologię, która mi wybaczy.

158
00:11:46,840 --> 00:11:50,080
Ale w każdym razie powiemy, że wszystkie

159
00:11:50,470 --> 00:11:55,390
psy, niezależnie od rasy i niezależnie od imienia, zawsze będą ssakami.

160
00:11:55,660 --> 00:11:57,200
Dlatego właśnie wysyłam ten atrybut

161
00:11:57,250 --> 00:12:03,610
jako atrybut obiektu klasy i dlatego, że jest to atrybut obiektu klasy i jest na zewnątrz tak jak w metodzie.

162
00:12:03,640 --> 00:12:06,260
Właściwie nie potrzebuję używać samouka,

163
00:12:06,310 --> 00:12:10,750
aby nieco pomniejszyć, abyśmy mogli zobaczyć cały obraz tutaj.

164
00:12:10,750 --> 00:12:11,620
Więc znowu mam tego psa klasy, miałem ten atrybut obiektu klasy.

165
00:12:13,390 --> 00:12:17,180
A kiedy zdefiniowałem instancję, pies musiał podać rasę i imię.

166
00:12:17,410 --> 00:12:21,850
Więc gdybym to powiedział i uruchomił, nie zobaczyłbym niczego innego.

167
00:12:22,050 --> 00:12:26,160
Ale teraz mam dostęp do tego atrybutu

168
00:12:26,470 --> 00:12:34,510
obiektu klasy, który w tym przypadku powiedzieliśmy, że whoops, a nie animal, jest gatunkiem.

169
00:12:35,140 --> 00:12:37,430
No to jedziemy.

170
00:12:37,450 --> 00:12:39,170
A potem zgłoszę się

171
00:12:39,240 --> 00:12:48,710
z powrotem ssakowi, ponieważ nie ma znaczenia, czy mam laboratorium, którego nazwisko jest Franki, dopóki jest to gatunek psa, zawsze będzie ssakiem.

172
00:12:48,710 --> 00:12:51,680
Każdy pies, niezależnie od rasy i imienia, zawsze będzie miał ten sam atrybut gatunku.

173
00:12:51,740 --> 00:12:56,300
Jest to celem atrybutu obiektu klasy, który jest atrybutem, który chcesz

174
00:12:56,300 --> 00:13:00,890
ustawić na stałe, niezależnie od tego, co może zaoferować użytkownik tej klasy.

175
00:13:01,280 --> 00:13:04,630
OK, to będzie coś, co zawsze będzie prawdziwe niezależnie od instancji psa.

176
00:13:05,000 --> 00:13:09,750
Do tej pory omawialiśmy podstawy składni klasy i podstawy

177
00:13:10,040 --> 00:13:16,310
wywoływania atrybutów, w tym tej metody, aby przypisać atrybuty do nowej instancji

178
00:13:16,320 --> 00:13:22,880
obiektu psa, jak również atrybuty obiektów klasowych, które będą miały ten sam atrybut,

179
00:13:22,910 --> 00:13:28,100
niezależnie od tego, wszystkich określonych atrybutów zadeklarowanych w metodzie init.

180
00:13:28,130 --> 00:13:29,590
W następnej części drugiej zaczniemy omawiać inne metody, które można dodać do klasy.

181
00:13:29,630 --> 00:13:35,330
Zobaczymy, czy są.

182
00:13:35,330 --> 00:13:35,960
&nbsp;
